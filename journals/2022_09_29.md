- #[[Operating Systems]]
	- ## Process Abstraction
		- A **process** is an instance of a program, running with limited "rights"
		- process $\ne$ program
			- a program is **passive entity** (executable file), while a process is **active entity** (has program counter indicating next instruction & set of allocated resources)
			- a program can have several processes
		- Process consists of two parts: address space and state
			- address space:
				- code, data, stack, heap
				- kernel stack
			- state (process control block or PCB):
				- registers, program counter, list of open files, etc.
	- ## Address Space Abstraction (Virtual Memory)
		- **Goals**:
			- Gives each process a private memory area for code, data, stack.
			- Prevent each process from reading/writing outside of its address space.
			- Allow sharing when needed.
		- **Implementation**:
			- OS manages address spaces, allocating physical memory.
			- HW performs address translation and protection, translating user addresses to physical addresses.
	- ## Process Control Block (PCB)
		- OS maintains information about every process in a data structure called a process control block (PCB).
		- ```c
		  struct proc {
		  uint sz; // Size of process memory (bytes)
		  pde_t* pgdir; // Page table
		  char *kstack; // Bottom of kernel stack for this process
		  enum procstate state; // Process state
		  int pid; // Process ID
		  struct proc *parent; // Parent process
		  struct trapframe *tf; // Trap frame for current syscall
		  struct context *context; // swtch() here to run process
		  void *chan; // If non-zero, sleeping on chan
		  int killed; // If non-zero, have been killed
		  struct file *ofile[NOFILE]; // Open files
		  struct inode *cwd; // Current directory
		  char name[16]; // Process name (debugging)
		  };
		  ```
	- ## Synchronization
		- Use atomic (all or nothing) operations to ensure cooperation among threads and avoidance of [[race conditions]]
			- {{embed ((63363e48-efc2-452b-b5be-7dbe8eadbe0b))}}
			- **Synchronization** helps maintain data consistency
			- **Mutual exclusions** help avoid [[race conditions]].
				- A shared resource is only accessed by one thread at a time.
			- **Critical Sections**: code vulnerable to a race condition
		- **Mutexes (Locks)**
			- Rules:
			  1. thread should lock before entering critical section
			  2. thread should unlock when leaving  critical section
			  3. thread should wait if critical section is locked
			  4. when one thread hols a lock, no other thread can hold it
			  5. only one thread can access shared state at a time
			- Properties:
				- **Safety**: at most one thread holds lock
				- **Liveness**: `lock.acquire()` to get lock
				- **Bounded waiting**: if one thread $T$ tries to get a lock, there's a bound on the # of times other threads get lock before $T$ does
			- Implementation:
			  1. disables interrupts
			  2. RMW instructions support atomic and isolated action